<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preact Signals</title>
</head>
<body>
   <script>
// 指向当前正在运行的 Effect
let currentTarget = undefined
class Signal {
    _value
    _targets = undefined // 记录依赖了那些 effect
    constructor(value) {
        this._value = value
    }

    get value() {
        let node = undefined
        // todo 依赖收集
        if (currentTarget !== void 0) {
            // 创建节点
            node = { signal: this, target: currentTarget, nextSignal: undefined }
            // 如果头节点存在
            if (this._targets) {
                // 将前一个节点 (effect) 的 prevTarget链接到最新的头节点
                this._targets.prevTarget = node
            }
            // 将最新的节点 (effect) 的 nextTarget 链接上一个节点（effect）
            node.nextTarget = this._targets
            // 添加到头节点
            this._targets = node
            // 将当前正在运行的 effect 的 _sources 链接到最新的节点的 nextSignal
            node.nextSignal = currentTarget._sources
            // 将最新的节点链接到当前正在运行的 effect 的 _sources
            currentTarget._sources = node
        }
        return this._value
    }

    set value(value) {
        if (this._value !== value) {
            this._value = value
            // todo 触发依赖
            for(let node = this._targets; node; node = node.nextTarget) {
                node.target && node.target._callback()
            }
        }
    }
}

function signal(value) {
    return new Signal(value)
}

class Effect {
    _sources = undefined // 记录订阅了哪些 signal
    _callback
    constructor(_callback) {
        this._callback = _callback
    }

    _run() {
        // 保存上一个 currentTarget
		const prevContext = currentTarget;
		try {
            // 设置当前正在运行的 Effect
			currentTarget = this;
            // 执行回调，期间会读取 Signal
			this._callback();
		} finally {
            // 恢复上一个 currentTarget
			currentTarget = prevContext;
		}
	}
    // 删除依赖
    _dispose() {
        // 遍历当前 effect 依赖的所有 signal 节点
        for (let node = this._sources; node; node = node.nextSignal) {
            // 获取该 signal 的依赖链表
            const _targets = node.signal._targets;
            const prev = node.prevTarget;
            const next = node.nextTarget;
            
            // 断开当前节点的前后连接
            node.prevTarget = undefined;
            node.nextTarget = undefined;

            // 从 signal 的链表中移除当前节点
            if (prev) {
                prev.nextTarget = next;  // 前一个节点指向下一个节点
            }
            if (next) {
                next.prevTarget = prev;  // 下一个节点指向前一个节点
            }
            
            // 如果当前节点是 signal 链表的头节点
            if (node === node.signal._targets) {
                node.signal._targets = next;  // 更新头节点为下一个节点
            }
        }
        
        // 清空 effect 的 sources 链表
        this._sources = undefined;
    }
}

function effect(callback) {
    const effect = new Effect(callback);
	effect._run();
    return effect
}

const count = signal(0);
const myEffect = effect(() => {
    console.log(`Count: ${count.value}`);
});

// 执行后打印: Count: 0

// 停止 effect 并清理依赖
myEffect._dispose();

// 此时修改 count 不会再触发 console.log
count.value = 1;  // 不会打印
   </script> 
</body>
</html>