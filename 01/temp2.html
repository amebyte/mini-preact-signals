<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preact Signals</title>
</head>
<body>
   <script>
let currentSignal;
let activating = false;
// 将需要更新的任务集中存储起来
const pending = new Set()
let oldDeps = new Set()
let batchPending = 0 // 0 表示没有批处理正在进行
class Signal {
    _subs = new Set()
    _deps = new Set()
    _pending = 0 // 更新标记计数器
    _value
    constructor(value) {
        this._value = value
    }

    get value() {
        if (currentSignal._canActivate || activating) {
            this._updater()
        }
        // 依赖收集
        this._subs.add(currentSignal)
        currentSignal._deps.add(this)
        oldDeps.delete(this)
        return this._value
    }

    set value(value) {
        if (this._value !== value) {
            this._value = value
            // 将需要更新的任务收集起来，等待最后再一起执行
            pending.add(this)
            // 只有当_pending为0时，才会标记订阅者，也就是标记过了，就不需要再标记，因为知道需要更新了
            if (this._pending === 0) {
				mark(this);
			}
            if (batchPending === 0) {
                sweep(pending)
                pending.clear()
            }
        }
    }

    _setCurrent() {
        let prevSignal = currentSignal
        let prevOldDeps = oldDeps
        currentSignal = this
        oldDeps = this._deps
        this._deps = new Set()
        return () => {
            console.log('oldDeps', oldDeps)
            oldDeps.forEach(sub => unsubscribe(this, sub))
            oldDeps.clear()
			oldDeps = prevOldDeps
            currentSignal = prevSignal
        }
    }

    _updater() {
        
    }
}

// 递归地标记它的所有订阅者（即依赖此信号的其他信号）
function mark(signal) {
    // 注意，这里使用的是后自增，所以条件判断时是0，然后变成1
	if (signal._pending++ === 0) {
        // 递归地标记
		signal._subs.forEach(mark);
	}
}

function sweep(subs) {
    subs.forEach(signal => {
        // _pending > 0 意味着信号已经被标记过了，需要更新
        if (signal._pending > 0) {
            // 这里是重点，不管被标记了多次，都通过递减_pending直到0才执行更新
            if (--signal._pending === 0) {
                signal._updater()
                sweep(signal._subs)
            }
        }
    })
}

function unsubscribe(signal, from) {
    console.log('signal', signal, from)
	signal._deps.delete(from)
	from._subs.delete(signal)
}

currentSignal = new Signal(undefined)
currentSignal._canActivate = true

function signal(value) {
    return new Signal(value)
}

function computed(compute) {
    const signal = new Signal(undefined)
    function updater() {
        const finish = signal._setCurrent()
        // const tmp = currentSignal
        // currentSignal = signal
        const ret = compute()
        signal._value = ret
        // currentSignal = tmp
        finish()
    }
    signal._updater = updater
    return signal
}

function effect(callback) {
    // 使用 batch 批量处理callback内部的多个信号更新
    const s = computed(() => batch(callback))
    activating = true
    s._updater()
    activating = false
}

function batch(cb) {
    batchPending++;  // 进入批处理，增加计数器
    // 防止用户代码报错，使用 try 语法
    try {
        cb()
    } finally {
        if (--batchPending === 0) {  // 退出最外层批处理
            sweep(pending)
            pending.clear() // 最后要清除所有的依赖
        }
    }
}

const a = signal("a")
const b = signal("b")
const cond = signal(true)

const c = computed(() => {
	return cond.value ? a.value : b.value
});

effect(() => {
	console.log('c', c.value)
})

// console.log('c', c.value)
a.value = 'bb'
cond.value = false
// console.log('c', c.value)
a.value = 'cc'
// cond.value = false
// console.log('c', c.value)
// a.value = 'cc'

// const a = signal("a")
// const b = signal("b")
// const cond = signal(true)

// const c = computed(() => {
// 	return a.value
// });

// console.log('c', c.value)
// a.value = 'bb'
// console.log('c', c.value)
// a.value = 'cc'
// cond.value = false
// console.log('c', c.value)
// a.value = 'aa'
// console.log('c', c.value)

   </script> 
</body>
</html>